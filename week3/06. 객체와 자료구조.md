# Ch.06 객체와 자료 구조
> **객체**는 동작을 공개하고 자료를 숨기고, **자료구조**는 별다른 동작 없이 자료를 노출한다 (정반대 조건)
>
> - 이 차이를 이해하고 시스템이 필요로 하는 유연성의 종류에 따라 최적의 해결책을 선택할 것.

### 목차
- [자료 추상화](#자료-추상화)
- [자료/객체 비대칭](#자료객체-비대칭)
- [디미터 법칙](#디미터-법칙)
  - [기차 충돌](#기차-충돌)
  - [잡종 구조](#잡종-구조)
  - [구조체 감추기](#구조체-감추기)
- [자료 전달 객체](#자료-전달-객체)
  - [활성 레코드](#활성-레코드)
- [결론](#결론)

<br/>

---

## 자료 추상화
- 자료를 세세하게 공개하기보다 **추상적인 개념**으로 표현하는 것이 좋다
  
  - 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 진정한 의미의 클래스 
- 개발자는 **객체가 포함하는 자료를 표현할 최적의 방법**을 심각하게 고민해야 함
  - 인터페이스나 조회/설정 함수만으로는 추상화 X
  - 아무 생각 없이 Getter/Setter 추가하는 게 최고 나쁨 😡
  ```java
  // 구체적인 클래스 예제
  public interface Vehicle {
    double getFeulTankCapacityInGallons();
    double getGallonsOfGasoline();
    // 자료를 세세하게 알려주는 조회함수
  }

  // 추상적인 클래스 예제 (better)
  public interface Vehicle {
    double getPercentFuelRemaining();
    // 보다 추상화된 개념(백분율)로 알려주는 함수
  }
  ```


## 자료/객체 비대칭
- 객체
  - 추상화 뒤로 자료는 숨기고 **자료를 다루는 함수만 공개**
- 자료 구조
  - **자료 그대로 공개**하고 별다른 함수 제공 X
- 객체와 자료 구조의 정의는 본질적으로 상반되고 상호보완적
  - 모든 것이 객체라는 생각은 미신.
  - **객체지향 코드는**
    - 장) 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉬움
    - 단) 새로운 함수를 추가하기 어려움 (모든 클래스를 고쳐야함)
  - **절차적인 코드는**
    - 장) 기존 자료 구조를 변경하지 않고 새 함수를 추가하기 좋음
    - 단) 새로운 자료 구조를 추가하기 어려움

<br/>

- 📖 **객체**면서 대상 객체가 잘 안바뀌고, 새로운 알고리즘(함수)을 추가하기에 좋은 방법? (like 절차적 코드)
  
  > #### VISITOR Pattern (방문자 패턴)
  > - 실제 로직을 가지고 있는 객체(Visitor)가 로직을 적용할 객체(Element)를 방문하면서 실행하는 패턴
  > - 즉, 로직과 구조를 분리하는 패턴. (=> 구조 수정 없이 기존 객체에 새로운 동작 추가 가능)
  > - [출처 - thecodinglog '방문자 패턴'](https://thecodinglog.github.io/design/2019/10/29/visitor-pattern.html)
  >
  > #### Dual-path
  >  - 🤔 **dual dispatch** 가 아닌가요?
  >     - 이중 디스패치(dual dispatch) : 실행되는 연산이 요청의 종류와 두 수신자의 타입에 따라 달라진다
  >     - 방문자 패턴도 dual-dispatch 기법을 활용한 패턴
  >  - [출처 - reduntan '클린 소프트웨어 Part6'](http://redutan.github.io/2017/10/08/clean-software-part06)



## 디미터 법칙
- **[디미터 법칙 (LoD)](http://en.wikipedia.org/wiki/Law_of_Demeter)** - "모듈은 자신이 조작하는 객체의 속사정을 몰라야한다"

  >*"클래스 C의 메서드 f는 다음과 같은 객체의 메서드만 호출해야한다."*
  >
  > - `클래스 C`, `f가 생성한 객체`, `f 인수로 넘어온 객체`, `C 인스턴스 변수에 저장된 객체`
  - 잘 알려진 Heuristic
  - 쉽게 **객체는 조회함수로 내부 구조를 공개하면 안된다**는 의미

### 기차 충돌
- 기차 충돌 (train wreck)
  - ~~기차처럼 보여지는 긴 호출 체인~~ => 조잡하고 지양되는 코드
  ```java
  final String outputDir = ctxt.getOptions().getScractchDir().getAbsolutePath();
  ```

- 𝐐. 그럼 기차 충돌을 해소하면 디미터 법칙을 충족하는가?
  ```java
  Options opts = ctxt.getOptions();
  File scratchDir = opts.getScratchDir();
  final String outputDir = scratchDir.getAbsolutePath();
  ```
  - 𝑨. cxtx, Options, ScatchDir 이 **[1]객체**면 명백한 위반, **[2]자료구조**라면 디미터 법칙 적용 안됨 (내부 구조를 노출하므로)
    - 사실 [2]자료구조였다면 `ctxt.options.scratchDir.absolutePath` 로 구현하면 더 간단
    - 그러나 자료구조에도 Getter/Setter 정의가 요구되는 프레임워크와 표준 (ex. bean) 이 존재하므로..

### 잡종 구조
- 절반은 객체, 절반은 자료구조
  - 중요한 기능을 수행하는 함수, 공개 변수나 공개 Getter/Setter 함수 등
  - => **기능 욕심(Feature Envy)** 야기
    - 절차적 프로그래밍의 자료 구조 접근 방식처럼 비공개 변수를 사용하고 싶은 유혹
- 양쪽의 단점만 모아놓은 어중간한 구조이므로 지양함
  - 새로운 함수도 자료구조도 추가하기 어려움

### 구조체 감추기
- [1]객체라면 내부 구조를 감춰야하므로 줄줄이 엮어서는 X
  - 객체라면 **"뭔가를 하라"** 고 말해야지 속을 드러내라고 하면 안된다
```java
// bad 1 - 공개해야하는 메서드가 너무 많아짐
ctxt.getAbsolutePathOfScratchDirectoryOption();

// bad 2 - ScatchDirectoryOption을 자료구조로 가정하게 됨
ctxt.getScratchDirectoryOption().getAbsolutePath();

// good - 절대 경로를 얻으려는 이유(임시파일 생성) 수행 자체를 객체한테 맡김
// 내부구조를 드러내지 않으면서, 몰라도 되는 객체를 탐색할 필요x
BufferedOutputStream bos = ctxt.createScratchFileStream(classFileName);
```

## 자료 전달 객체
- 자료 구조체의 전형적 형태 _ 공개 변수만 있고 함수가 없는 클래스
  - **자료 전달 객체**(**DTO**, Data Transfer Object)
  - Database의 가공되지않은 정보 --(DTO)--> 어플리케이션에서 사용할 객체
- 좀 더 일반적인 형태 _ **'빈(bean)'** 구조
  - private 변수를 Getter/Setter 로 조작
  - 저자는 일종의 사이비 캡슐화이며 별 이익은 없다는 의견


### 활성 레코드
- 활성 레코드
  - DTO의 특수한 형태
    - 공개 변수 혹은 비공개 변수에 조회/설정함수가 있는 자료 구조
    - \+ save, find 같은 탐색함수도 제공
  - Database Table이나 다른 소스에서 자료를 직접 변환한 결과
- **활성 레코드는 자료 구조이다**
  - ~~활성 레코드에 비즈니스 규칙 메서드를 추가해 객체처럼 사용하는 경우~~ => 잡종 구조
  - 필요하다면 비즈니스 규칙을 담으면서 내부 자료(ex. 활성 레코드의 인스턴스)를 숨기는 객체를 따로 생성할 것

## 결론

- **객체**는 동작을 공개하고 자료를 숨긴다
  - 기존 동작을 변경하지 않으면서 **새 객체 타입 추가가 쉬움**
  - 기존 객체에 새 동작 추가는 어려움
- **자료구조**는 별다른 동작 없이 자료를 노출한다
  - 기존 자료 구조에 **새 동작을 추가하기 쉬움**
  - 기존 함수에 새 자료 구조 추가는 어려움

- 즉, 새로운 자료타입을 추가하는 유연성이 필요하면 **객체**를, 새로운 동작을 추가하는 유연성이 필요하면 **자료 구조와 절차적인 코드**가 적합
- 우수한 소프트웨어 개발자는 편견 없이 이 사실을 이해하고 최적의 해결책을 선택! 🤓✨
