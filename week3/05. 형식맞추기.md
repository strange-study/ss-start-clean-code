# Ch.05 형식 맞추기
> 프로그래머라면 형식을 깔끔하게 맞춰 코드를 짜야한다.
>
> - 간단한 규칙(Code Convention)을 정하고 착실히 따를 것.
> - 코드를 읽는 독자들이 전문가가 짰다는 인상을 심어줄 수 있도록 일관적이고 질서 정연한 코드를 짤 것.


### 목차
- [형식을 맞추는 목적](#형식을-맞추는-목적)
- [적절한 행 길이를 유지하라](#적절한-행-길이를-유지하라)
  - [신문 기사처럼 작성하라](#신문-기사처럼-작성하라)
  - [개념은 빈 행으로 분리하라](#개념은-빈-행으로-분리하라)
  - [세로 밀집도](#세로-밀집도)
  - [수직 거리](#수직-거리)
  - [세로 순서](#세로-순서)
- [가로 형식 맞추기](#가로-형식-맞추기)
  - [가로 공백과 밀집도](#가로-공백과-밀집도)
  - [가로 정렬](#가로-정렬)
  - [들여쓰기](#들여쓰기)
  - [가짜 범위](#가짜-범위)
- [팀규칙](#팀규칙)
- [밥 아저씨의 형식 규칙](#밥-아저씨의-형식-규칙)

<br/>
---
## 형식을 맞추는 목적
- **코드 형식은 중요하다**
  - 의사소통의 일환으로, 개발자의 1차적 의무
- 개발자의 1차적 의무는 ~~'돌아가는 코드'~~ 가 아닌가? 
  - => 언제든지 바뀔 수 있는 기능보다 **원활한 소통이 되는 가독성 높은 코드**
  - 시간이 지나 코드가 바뀌어도, 맨 처음 잡아놓은 구현 스타일과 가독성 수준은 유지보수 용이성 & 확장성에 계속 영향

## 적절한 행 길이를 유지하라
- 세로 길이 (파일 크기)
  - [p.97 그림 5.1] 프로젝트 7개의 파일 길이 분포, 로그 배율
    - 대다수 200줄 미만 (500줄 초과 X)
  - 큰 파일보다 작은 파일이 이해하기 쉽다

### 신문 기사처럼 작성하라
- 신문 기사
  - 위에서 아래로 읽고, 최상단에는 기사를 요약하는 **표제**
  - 첫 문단에서는 기사 내용을 요약하고 커다란 그림을 보여주고, 읽으며 내려갈 수록 세세한 사실이 드러남
- 소스 파일
  - 간단하면서 설명이 가능한 **이름**
  - 첫 부분은 고차원 개념과 알고리즘을 설명하고, 아래로 내려갈 수록 저차원 함수와 세부적인 의도를 나타냄
  - => '읽을 만한 신문'의 기사처럼 코드를 작성할 것

### 개념은 빈 행으로 분리하라
- 줄바꿈은 개념을 분리
- 각 행은 수식・절, 행 묶음은 '완결된 생각' 하나를 표현한다.
  - 빈 행은 **새로운 생각(개념)** 이 시작한다는 시각적 단서

### 세로 밀집도
- 세로 밀집도는 **연관성**을 의미
  - **서로 밀접한 코드 행**은 세로로 가깝게
  - [목록 5-3] 세로 밀집도를 위배한 예 ([Chapter 04. 주석의 나쁜 예](/week2/04.%20주석.md#같은-이야기를-중복하는-주석)에도 해당) 
  ```java
  // bad case
  public class ReporterConfig {
    /**
     * 리포터 리스너의 클래스 이름
     */
    private String m_className;

    /**
     * 리포터 리스너의 속성
     */
    private List<Property> m_properties = new ArrayList<Property>();
    public void addProperty(Property property) {
      m_properties.add(properties);
    }
  }
  ```

### 수직 거리
- **서로 밀접한 개념**은 세로로 가깝게
  - 두 개념이 다른 파일에 속할땐 예외지만, 타당한 근거가 없으면 한 파일에 속해야 마땅
  - => 🤔`protected` 변수를 피해야하는 이유
    - [왜 protected 변수를 피하라고 할까? - 출처 : stackexchange](https://softwareengineering.stackexchange.com/questions/162643/why-is-clean-code-suggesting-avoiding-protected-variables)
    - 여기에서는 변수와 해당 변수에 영향을 줄 수 있는 범위를 한 파일에 두고자? (=가까운 수직 거리)
- 연관성 : 한 개념을 이해하는 데 다른 개념이 중요한 정도
  - 즉, 코드를 읽는 사람이 개념을 이해하기 위해 소스 파일 여기저기를 뒤지게 않게 작성할 것

- **변수 선언** 은 사용하는 위치에 최대한 가까이
  > - 지역변수 -> 각 함수의 맨 처음
  > - 루프 제어 변수 -> 루프 문 내부에
  > - 긴 함수에서는 블록 상단이나 루프 직전에

- **인스턴스 변수** 는 클래스 최상단에
  > - 상단이든 하단이든 잘 알려진 위치에 인스턴스 변수를 모은다는 사실이 중요 (모두가 알고있는 위치여야)
  > - cf. C++은 클래스 마지막에 선언 (가위 규칙, scisors rule), Java는 클래스 맨 처음에

- **종속 함수** 는 호출하는 함수와 호출되는 함수를 가깝게 선언
  > - 호출하는 함수 -> 호출되는 함수 순으로 선언하는 것이 가독성 good
  > - \+ (p.105 - 잘 알려져야하는 상수는 저차원 함수에 묻히게 두기보다, 상수를 알아야 마땅한 함수에서 실제 사용하는 함수로 상수를 넘겨주는 방식이 더 좋다)

- **개념적 유사성(친화도)** 가 높은 코드일수록 서로 가까이 
  > - ex.
  > - 호출하는 함수 <-> 호출되는 함수 (직접적인 종속성)
  > - 변수 <-> 그 변수를 사용하는 함수
  > - **비슷한 동작을 수행하는 일군의 함수**
  >   - 종속성이 없더라도 명명법이 같고 기본 기능이 유사


  ```java
  // '비슷한 동작을 수행하는 일군의 함수' 예제
  // 이 경우 개념적 친화도가 높아 함수간의 호출 관계(종속)는 just 부차적 요인
  public class Assert {
    static public void assertTrue(String message, boolean condition) {
      if (!condition)
        fail(message);
    }

    static public void assertTrue(boolean condition) {
      assertTrue(null, condition);
    }

    static public void assertFalse(String message, boolean condition) {
      assertTrue(message, !condition);
    }

    static public void assertFalse(boolean condition) {
      assertFalse(null, condition);
    }
  }
  ```

### 세로 순서
- 함수 호출 종속성은 아래 방향으로 유지
  - 함수를 호출하는 함수 -> 호출되는 함수 순으로 배치 (<-> 파스칼, C, C++)
  - 고차원에서 저차원으로 내려가게
- 가장 중요한 개념을 가장 먼저 표현 _ 🔗["신문기사처럼 작성하라"](#신문-기사처럼-작성하라)

### 가로 형식 맞추기
- [p.107 그림 5.2] 자바 행 길이 분포
  - 10자 미만 30%, 20~60자 40%, 80자 이상은 소수
- **짧은 행이 바람직**하다
  - 과거 Hollerith의 80자 제한
  - 100-120자 정도는 괜찮으나 그 이상은 X

### 가로 공백과 밀집도
- 공백을 사용한 밀접한 개념 / 느슨한 개념 표현

  > - 할단 연산자 앞뒤 공백 (확실한 요소 구분)
  >   - `int lineSize = line.length();`
  > - 함수 이름과 괄호에는 공백 X (밀접함 표현)
  >   - `recordWidestLine(lineSize);`
  > - 함수 인자들 사이 공백 (인수의 별개성)
  >   - `addLine(lineSize, lineCount);`
  > - 연산자 우선순위 강조를 위해서도 사용 `* vs + vs ..`
  >   - but, 대부분의 Code Style 툴에서는 같은 간격을 적용하므로 자동으로 없애는 경우가 많다

### 가로 정렬
- ~~과거 선언부의 변수이름이나 피연산자들을 정렬하는 방식~~ 
  - => 엉뚱한 부분을 강조하여 진짜 의도가 가려짐
  - 변수 유형이나 할당 연산자는 무시하고 오른쪽 변수 이름이나 피연산자만 읽게 됨
- 선언문과 할당문은 **정렬하지 마라**
  - 정렬하지 않는 것이 중대한 결함을 찾기 좋음
  - 정렬이 필요할 정도로 목록이 길다면 문제는 목록의 길이
    - 정렬이 아닌 클래스를 쪼개서 해결할 것

### 들여쓰기
- 소스파일은 윤곽도(outline)과 계층이 비슷
- 계층에서 각 수준은 *이름을 선언하는 범위* 이자 *선언문과 실행문을 해석하는 범위*
- **범위(scope)** 로 이루어진 계층을 표현하기 위한 **들여쓰기**
  - 코드가 속하는 범위를 시각적으로 표현함으로써 구조를 파악하기 쉽게 한다
  - **들여쓰기 무시하기** 의 유혹에 빠지지 말 것
    ```java
    // bad case (한 행에 범위 뭉뚱그리기)
    public CommentWidget(ParentWidget parent, String text){super(parent, text);}
    public String render() throws Exception {return "";}


    // good case
    public CommentWidget(ParentWidget parent, String text) {
      super(parent, text);
    }
    
    public String render() throws Excpetion {
      return "";
    }
    ```

### 가짜 범위
- 빈 while 문, for 문도 피할 것
  ```java
  while (dix.read(buf, 0, readBufferSize) != -1)
  ;
  ```

## 팀 규칙
- 프로그래머 개인이 선호하는 규칙이 있더라도, 팀에 속한다면 **팀 규칙**을 선호해야한다.
  - 팀은 한 가지 규칙에 합의하고 팀원 모두가 따라야 software 가 일관적인 스타일을 보임
  - **스타일은 일관적이고 매끄러워야** -> 독자에게 신뢰감

## 밥 아저씨의 형식 규칙
- 좋은 소프트웨어 시스템은 읽기 쉬운 문서로 이루어짐
- 코드 자체가 최고의 구현 표준 문서
  - p.114-116
