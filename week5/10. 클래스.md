# Chapter 10. 클래스
## 클래스 체계
- 추상화 단계가 순차적으로 내려가기 때문에 프로그램은 신문기사 처럼 읽힌다.
``` JAVA
public class SampleClass {
  /** 변수 목록 **/
  pubilc static final int A = 1;  // 정적 공개 상수
  private static int B = -1; // 정적 비공개 변수
  private String C; // 비공개 인스턴트 변수
  // 공개 변수는 거의 필요하지 않다
  
  
  /** 함수 목록 **/
  public void setSomething(){ } // 공개 함수
  .
  .
  
  public int getSomthing(){
    .
    .
    return calculateSomething(a);
  }
  
  private int calculateSomething(int a){ }  
  .   // 비공개 함수는 자신을 호출하는 공개함수 뒤에 나온다.
  .
  
}
```
- _캡슐화_ 는 최후의 수단이다. 변수와 함수는 반듯이 숨겨야한다는 법칙은 없기 때문에 protected를 통해 공개할 수 있지만 그 전에 비공개를 유지할 온갖 방법을 강구 할 것.
  
## 클래스는 작아야 한다!
- 함수는 물리적인 행수로 크기를 측정한다면 클래스는 클래스가 맡은 책임을 센다.

```JAVA
public class SuperDashboard extends JFrame implements MetaDataUser {
    public Component getLastFocusedComponent()
    public void setLastFocused(Component lastFocused)
    public int getMajorVersionNumber()
    public int getMinorVersionNumber()
    public int getBuildNumber() 
}
```
(컴포넌트에 접근하는 방법과 버전 빌드 번호를 추적하는 매커니즘 제공)
- 메서드 수가 작으나 책임이 많다.
- 클래스의 간결한 이름이 떠오르지 않고 모호하다면 클래스가 큰 것.
- 클래스 설명은 if/and/or/but 을 사용하지 않고 25단어 내외 일 것.
  
### [단일 책임 원칙 (SRP, Single Responsibility Principle)]
- SRP는 클래스나 모듈을 변경할 이유(= 즉, 책임)가 단 하나여야 한다는 원칙이다.
- SuperDashboard는 변경해야할 이유가 2개
  1. 소프트웨어 버전 정보가 바뀔 때 
  2. 스윙 컴포넌트를 관리하므로 스윙 코드 변경 시 
- 책임, 변경할 이유를 파악하다보면 추상화가 쉬워진다. 
-> 버전 정보를 다루는 메서드를 빼내 Version이라는 독자적 클래스를 만든다.

- SRP는 객체 지향 설계에서 아주 중요한 개념이지만 우리는 수많은 책임을 가진 크래스를 접하는 이유?
  > '돌아가는 소프트웨어'에 초점을 맞춘 뒤, 다음 단계인 '깨끗하고 체계적인 소프트웨어'로 넘어가지 않는다.
  > 도구상자를 어떻게 관리하고 싶은가? 작은 서랍을 많이 두고 기능과 이름이 명확한 컴포넌트를 나누고 싶은가? 
  > 큰 서람을 몇 개 두고 모두 던져 넣고 싶은가?  
  > 규모가 큰 프로젝트에서 복잡성을 다루려면 체계적인 정리가 필수이다. 그래야 직접 영향이 미치는 컴포넌트만 이해해도 충분하다.

### [응집도 (Cohesion)]
- [높은 응집도와 낮은 결합도](https://smiler.tistory.com/entry/%EB%86%92%EC%9D%80-%EC%9D%91%EC%A7%91%EB%8F%84%EC%99%80-%EB%82%AE%EC%9D%80-%EA%B2%B0%ED%95%A9%EB%8F%84)
- 프로그램의 한 요소가 해당 기능을 수행하기 위해 얼마만큼의 연관된 책임과 아이디어가 뭉쳐있는지를 나타내는 정도이다. 일반적으로 프로그램의 한 요소가 특정 목적을 위해 밀접하게 연관된 기능들이 모여서 구현되어 있고, 지나치게 많은 일을 하지 않으면 그것을 응집도가 높다고 표현한다. 응집도가 높으면 프로그램을 쉽게 이해할 수 있으므로 유지보수성이 높아진다.
  > - 클래스는 인스턴스 변수 수가 작아야 한다. 
  > - 각 메서드는 클래스 인스턴스 변수를 하나 이상 사용해야한다.
  > - 일반 적으로 변수를 더 많이 사용할수록 메서드와 클래스는 응집도가 높다.
  > - 모든 인스턴스 변수를 메서드마다 사용하는 클래스는 응집도가 가장 높다.
  
- 몇몇 메서드만이 사용하는 인스턴스 변수가 많아진다는 것은 새로운 클래스로 쪼개야 한다는 신호. (큰 함수를 작은 함수로 쪼개는 과정에서 이러한 현상이 많아지므로 클래스로도 쪼갤 기회가 생기곤 한다.)

## 변경하기 쉬운 클래스
### [SQL 예제]
- 문제점
  - 변경할 이유가 여러개라 SRP 위반
  - 구조적인 관점에서도 selectWithCriteria라는 비공개 메서드가 select문을 처리할 때만 사용한다. (클래스 일부에서만 사용되는 비공개 메서드는 코드를 개선할 잠재적 여지 준다.)
  _BUT 실제로 개선하는 것은 시스템이 변할 때 여야한다. 해당 클래스를 논리적 완성으로 여기거나 향후 메서드를 추가하지 않을 것이면 내버려두는 편이 좋다._
- 방법
  - 공개 인터페이스를 각각 SQL 클래스에서 파생하는 클래스로 생성
  - 비공개 메서드는 해당하는 파생 클래스로 이동
  - 공통으로 사용하는 비공개 메서드는 유틸리티 클래스로 생성
- 결과
  - 함수 하나를 수정함으로서 다른 함수가 망가질 위험이 사라짐
  - 테스트 관점에서 모든 논리를 구석구석 증명하기가 쉬워짐
  - update문 추가 시 기존 클래스 변경이 불필요
  - OCP(Open-Closed principle)만족 _클래스는 확장에 개방적이고 수정에 폐쇠적이여야함_
  
### [변경으로부터의 격리]
- 상세한 구현에 의존하는 클래이언트 클래스는 구현이 바뀌면 위험에 빠진다, 그러므로 인터페이스와 추상 클래스를 사용해 구현이 미치는 영향을 격리한다.
- 방법
  - 클래스를 만들때 외부 API(ex. 값이 수시로 변해 테스트가 용이하지 않은 경우)를 직접 호출 하지 않고, 인터페이스를 생성하고 해당 API를 이용하여 이 인터페이스를 구현하는 클래스를 구현한다.
  - 해당 인터페이스를 구현하는 테스트용 클래스를 작성한다.

- 테스트가 가능할 정도로 시스템의 결합도를 낮추면 유연성과 재사용성도 더욱 높아진다.
- 결합도가 낮은 것은 각 시스템 요소가 다른 요소로부터, 변경으로부터 잘 격리되어 있다는 의미
- 시스템 요소가 서로 잘 격리되어 있으면 각 요소를 이해하기 더 쉬움
- DIP(Dependency Inversion Principle)만족 _클래스가 상세한 구현이 아니라 추상화에 의존해야 한다._
 
  
### Reference
[code 있는 블로그](http://amazingguni.github.io/blog/2016/06/Clean-Code-10-%ED%81%B4%EB%9E%98%EC%8A%A4)
